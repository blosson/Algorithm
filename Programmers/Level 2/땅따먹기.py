# <IDEA>
# 단순히 각 행의 최댓값을 구하고 그 아래 행에서는 이전 열을 제외하는 방식으로 문제를 풀게되면 예외가 발생하게 된다. 
# 예시 : [[4, 3, 2, 1], [2, 2, 2, 1], [6, 6, 6, 4], [8, 7, 6, 5]]

# 그렇다고 모든 경우의 수를 따지기에는 100,000행까지 들어오기 때문에 4**100,000을 계산해야하므로 시간초과가 날 것이다.
# 그렇다면 어떻게 해결하면 좋을까 고민하다가 DP를 써야함을 알게 되었다.

# 1. 1번째 행부터 행부터 순회하며 이전 행에서 본인의 열을 제외한 값들의 최댓값을 본인의 값과 더해 계속 쌓아나가준다.
# 2. 이를 점화식 형태로 표현해주고 마지막 행의 최댓값을 찾는다.


def solution(land):
    # index 0번 줄은 이미 숫자가 나와있으니 1번 줄부터 순회
    for i in range(1, len(land)):
        # 자기자신 + 이전줄의 같은 열을 제외한 최댓값을 더해서 현재 행의 최댓값을 쌓아나가줌
        for j in range(4):
            # land[i-1][:j] + land[i-1][j+1:] => 리스트끼리 덧셈하면 리스트 연결됨
            # ex) [1, 2] + [3] = [1, 2, 3], 리스트가 없으면 어차피 []이라 덧셈에 문제 없음
            land[i][j] += max(land[i-1][:j] + land[i-1][j+1:])
    
    answer = max(land[len(land) - 1])
    return answer


# 2 다른풀이

def solution(land):
    n = len(land)

    # dp[i][j] = i행 j열에서 점수의 최대값
    dp = [[0,0,0,0]] + land
    for i in range(1, n+1):
        dp[i][0] += max(dp[i-1][1], dp[i-1][2], dp[i-1][3])
        dp[i][1] += max(dp[i-1][0], dp[i-1][2], dp[i-1][3])
        dp[i][2] += max(dp[i-1][0], dp[i-1][1], dp[i-1][3])
        dp[i][3] += max(dp[i-1][0], dp[i-1][1], dp[i-1][2])

    return max(dp[n])